from selenium.webdriver.support.relative_locator import locate_withfrom webdriver_helper import *from selenium.webdriver.common.by import By"""需求：定位a标签内的名称以及p元素内的金额<div class="outer-con">    <div class="goods-title am-text-truncate-2 am-margin-bottom-xs">        <a href="http://101.34.221.219:8010/?s=goods/index/id/10.html" target="_blank">夏装女装古力娜扎明星同款一字领露肩蓝色蕾丝修身显瘦连衣裙礼服</a>    </div>    <!-- 首页楼层商品售价顶部钩子 -->                                                <p class="price am-text-truncate">￥228.00</p></div>"""with get_webdriver() as driver:    driver.get('http://101.34.221.219:8010/')    # 不使用相对定位    name = driver.find_element(By.XPATH, '//*[@id="floor2"]/div[2]/div[2]/div[3]/div/div/a')    price = driver.find_element(By.XPATH, '//*[@id="floor2"]/div[2]/div[2]/div[3]/div/p')    print(name.text, price.text)    # 使用相对定位：    ele = driver.find_element(By.XPATH, '//*[@id="floor2"]/div[2]/div[2]/div[3]/div')    name = ele.find_element(By.XPATH, './div/./a')    price = ele.find_element(By.XPATH, './p')    # 也可以使用：    # 其中ele表示父类元素位置， .表示此父类的子类  //a表示父类的子类中的所有a/p元素(a/p标签)    name1 = ele.find_element(By.XPATH, './/a')    price1 = ele.find_element(By.XPATH, './/p')    print(name.text, price.text)    print(name1.text, price1.text)    """    轴定位：    ancestor	            选取当前节点的所有先辈（父、祖父等）。    ancestor-or-self	    选取当前节点的所有先辈（父、祖父等）以及当前节点本身。    attribute	            选取当前节点的所有属性。    child	                选取当前节点的所有子元素。    descendant	            选取当前节点的所有后代元素（子、孙等）。    descendant-or-self	    选取当前节点的所有后代元素（子、孙等）以及当前节点本身。    following	            选取文档中当前节点的结束标签之后的所有节点。    namespace	            选取当前节点的所有命名空间节点。    parent	                选取当前节点的父节点。    preceding	            选取文档中当前节点的开始标签之前的所有节点。    preceding-sibling	    选取当前节点之前的所有同级节点。    self	                选取当前节点。    """    ele = driver.find_element(By.XPATH, '//*[@id="floor1"]/div[2]/div[2]/div[3]/div/div/a')    price2 = ele.find_element(By.XPATH, 'ancestor::*/child::p')    price3 = ele.find_element(By.XPATH, 'ancestor::*[2]/p')  # [2]表示 从父类"ancestor::*"的结果集内找到第二个结果    name2 = ele.find_element(By.XPATH, '//*[@id="floor1"]/div[2]/div[2]/div[3]/div/div/a')    print(price2.text, name2.text)    print(price3.text)    """    实例：    child::book	选取所有属于当前节点的子元素的 book 节点。    attribute::lang	选取当前节点的 lang 属性。    child::*	选取当前节点的所有子元素。    attribute::*	选取当前节点的所有属性。    child::text()	选取当前节点的所有文本子节点。    child::node()	选取当前节点的所有子节点。    descendant::book	选取当前节点的所有 book 后代。    ancestor::book	选择当前节点的所有 book 先辈。    ancestor-or-self::book	选取当前节点的所有 book 先辈以及当前节点（如果此节点是 book 节点）    child::*/child::price	选取当前节点的所有 price 孙节点。    """    """    selenium4提供的相对定位方法：    above 在指定元素上方进行搜索    below 在指定元素下方进行搜索    to_left_of 在指定元素左侧进行搜索    to_right_of 在指定元素右侧进行搜索    near 在指定元素附近（50px）进行搜索        原理：：：通过js代码，遍历附近所有元素的rect（坐标和大小），然后进行元素筛选定位    优势：：：根据元素实际展示效果进行定位，不关新具体层级    弊端：：：效率低下，准确率低，通用性差，无法按照预期进行工作    """    ele = driver.find_element(By.XPATH, '//*[@id="floor2"]/div[2]/div[1]/div[1]/a[3]')    n_ele = driver.find_element(locate_with(By.TAG_NAME, 'a').above(ele))    print(n_ele.text)    assert n_ele.text == '女装'    n_ele = driver.find_element(locate_with(By.TAG_NAME, 'a').below(ele))    print(n_ele.text)    assert n_ele.text == '女鞋'    n_ele = driver.find_element(locate_with(By.TAG_NAME, 'a').to_right_of(ele))    print(n_ele.text)    assert n_ele.text == '运动'